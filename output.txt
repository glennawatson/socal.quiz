import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";
import { verify  } from 'discord-verify';
import { DiscordBotService } from "../handlers/discordBotService";
import {APIInteraction, InteractionResponseType, InteractionType} from "discord-api-types/v10";
import {throwError} from "../util/errorHelpers"; // Assuming your existing service

// Environment variables
const token = process.env.DISCORD_BOT_TOKEN ?? throwError('Must have a valid token');
const clientId = process.env.DISCORD_CLIENT_ID ?? throwError('Must have a valid discord client id');
const publicKey = process.env.DISCORD_PUBLIC_KEY ?? throwError('Must have a valid discord public id');

// Initialize the Discord bot service
const discordBotService = new DiscordBotService(token, clientId);

// Register commands
(async () => {
    await discordBotService.start();
})();

export async function interactions(request: HttpRequest, context: InvocationContext): Promise<HttpResponseInit> {
    context.log(`Http function processed request for url "${request.url}"`);

    // 1. Verify Request (using discord-verify)
    const signature = request.headers.get('x-signature-ed25519');
    const timestamp = request.headers.get('x-signature-timestamp');
    const rawBody = await request.text();

    // 2. Parse Interaction
    const interaction = JSON.parse(rawBody) as APIInteraction;

    const isValid = await verify(
        rawBody,
        signature,
        timestamp,
        publicKey,
        crypto.subtle);

    if (!isValid) {
        return { status: 401, body: 'Invalid request signature' };
    }

    // 3. Handle PING Interactions
    if (interaction.type === InteractionType.Ping) {
        return { status: 200, body: JSON.stringify({ type: InteractionResponseType.Pong }) };
    }

    // 4. Delegate to DiscordBotService
    const response = await discordBotService.handleInteraction(interaction); // Updated to use interaction directly
    return {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(response)
    };
}

app.http('interactions', {
    methods: ['POST'],
    authLevel: 'anonymous',
    handler: interactions
});
import {IModalHandlerCommand} from "./discordCommand";
import {addQuestion} from "../../util/questionStorage";
import {
    APIChatInputApplicationCommandInteraction, APIInteractionResponse,
    APIModalSubmitInteraction,
    InteractionResponseType,
    MessageFlags, TextInputStyle
} from "discord-api-types/v10";
import {
    ActionRowBuilder, ModalBuilder,
    SlashCommandBuilder,
    SlashCommandOptionsOnlyBuilder,
    TextInputBuilder
} from "@discordjs/builders";
import { v4 as uuidv4 } from "uuid";
import {Question} from "../../question";
import {createEphemeralResponse} from "../../util/interactionHelpers";

export class AddQuestionToBankCommand implements IModalHandlerCommand {
    private componentIds = {
        bankName: "questionBankName",
        questionText: "questionText",
        imageUrl: "imageUrl",
        explanation: "explanation",
        explanationImageUrl: "explanationImageUrl",
        answers: Array.from({ length: 4 }, (_, i) => `answer${i + 1}`),
        correctAnswerIndex: "correctAnswerIndex",
    };

    data(): SlashCommandOptionsOnlyBuilder {
        return new SlashCommandBuilder()
            .setName(this.name)
            .setDescription("Add a question to a question bank");
    }

    name = 'addQuestionToBank';

    // Helper function to create text input components
    private createTextInput(customId: string, label: string, style: TextInputStyle, required = true) {
        return new TextInputBuilder()
            .setCustomId(customId)
            .setLabel(label)
            .setStyle(style)
            .setRequired(required);
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    public async execute(_: APIChatInputApplicationCommandInteraction): Promise<APIInteractionResponse> {
        const modal = new ModalBuilder()
            .setCustomId(this.name)
            .setTitle('Add New Question');

        modal.addComponents(
            new ActionRowBuilder<TextInputBuilder>().addComponents(
                this.createTextInput(this.componentIds.bankName, 'Question Bank Name', TextInputStyle.Short),
            ),
            new ActionRowBuilder<TextInputBuilder>().addComponents(
                this.createTextInput(this.componentIds.questionText, 'Question Text', TextInputStyle.Paragraph),
            ),
            new ActionRowBuilder<TextInputBuilder>().addComponents(
                this.createTextInput(this.componentIds.imageUrl, 'Image URL (optional)', TextInputStyle.Short, false),
            ),
            new ActionRowBuilder<TextInputBuilder>().addComponents(
                this.createTextInput(this.componentIds.explanation, 'Explanation (Optional)', TextInputStyle.Paragraph, false),
            ),
            new ActionRowBuilder<TextInputBuilder>().addComponents(
                this.createTextInput(this.componentIds.explanationImageUrl, 'Explanation Image URL (Optional)', TextInputStyle.Short, false),
            )
        );

        // Add answer input components (defaulting to 4 answers)
        for (const answerId of this.componentIds.answers) {
            modal.addComponents(
                new ActionRowBuilder<TextInputBuilder>().addComponents(
                    this.createTextInput(answerId, `Answer ${answerId.replace('answer', '')}`, TextInputStyle.Short),
                ),
            );
        }

        // Correct answer index (last row)
        modal.addComponents(
            new ActionRowBuilder<TextInputBuilder>().addComponents(
                this.createTextInput(this.componentIds.correctAnswerIndex, 'Correct Answer Index (0-based)', TextInputStyle.Short),
            ),
        );

        return {
            type: InteractionResponseType.Modal,
            data: modal.toJSON(),
        };
    }

    public async handleModalSubmit(interaction: APIModalSubmitInteraction): Promise<APIInteractionResponse> {
        const components = interaction.data.components;

        // Helper function to extract values based on custom IDs
        const getComponentValue = (customId: string) => components?.find(row => row.components?.[0]?.custom_id === customId)?.components?.[0]?.value;

        // Extract values using the componentIds map
        const bankName = getComponentValue(this.componentIds.bankName) as string;
        const questionText = getComponentValue(this.componentIds.questionText) as string;
        const imageUrl = getComponentValue(this.componentIds.imageUrl);
        const explanation = getComponentValue(this.componentIds.explanation);
        const explanationImageUrl = getComponentValue(this.componentIds.explanationImageUrl);

        // Extract answers
        const answers = this.componentIds.answers.map(answerId => ({
            answerId: uuidv4(),
            answer: getComponentValue(answerId) as string,
        }));

        const correctAnswerIndexStr = getComponentValue(this.componentIds.correctAnswerIndex);

        if (!correctAnswerIndexStr) {
            return {
                type: InteractionResponseType.ChannelMessageWithSource,
                data: {
                    content: "Invalid correct answer index. Please enter a number between 0 and 3.",
                    flags: MessageFlags.Ephemeral,
                },
            };
        }

        const correctAnswerIndex = parseInt(correctAnswerIndexStr, 10);
        if (isNaN(correctAnswerIndex) || correctAnswerIndex < 0 || correctAnswerIndex >= answers.length) {

            return {
                type: InteractionResponseType.ChannelMessageWithSource,
                data: {
                    content: "Invalid correct answer index. Please enter a number between 0 and 3.",
                    flags: MessageFlags.Ephemeral,
                },
            };
        }

        const question: Question = {
            bankName,
            questionId: uuidv4(),
            question: questionText,
            answers,
            correctAnswerIndex,
            imageUrl,
            explanation,
            explanationImageUrl,
        };

        await addQuestion(question);

        return createEphemeralResponse(`Added question to bank ${bankName}.`);
    }
}
import {NextQuestionCommand} from "./nextQuestionCommand";
import {AddQuestionToBankCommand} from "./addQuestionToBankCommand";
import {DeleteQuestionFromBankCommand} from "./deleteQuestionFromBankCommand";
import {StopQuizCommand} from "./stopQuizCommand";
import {StartQuizCommand} from "./startQuizCommand";
import {DeleteQuestionBankCommand} from "./deleteQuestionBankCommand";
import {IDiscordCommand, IModalHandlerCommand} from "./discordCommand";
import {DiscordBotService} from "../discordBotService";
import {
    APIInteraction,
    APIInteractionResponse,
    APIModalSubmitInteraction,
    InteractionResponseType,
    InteractionType,
    MessageFlags,
    Routes
} from "discord-api-types/v10";
import {isChatInputApplicationCommandInteraction} from "discord-api-types/utils";
import {REST} from "@discordjs/rest";
import {createEphemeralResponse} from "../../util/interactionHelpers";

export class CommandManager {
    private readonly commands: Map<string, IDiscordCommand>;

    constructor(private botService: DiscordBotService, private clientId: string, private rest: REST) {
        this.commands = new Map();
    }

    public async handleInteraction(interaction: APIInteraction): Promise<APIInteractionResponse | null> {
        if (interaction.type == InteractionType.ModalSubmit) {
            const command = this.commands.get(interaction.data.custom_id);

            if (!command) {
                return createEphemeralResponse("could not find modal: " + interaction.data.custom_id);
            }

            return await (command as IModalHandlerCommand).handleModalSubmit(interaction as APIModalSubmitInteraction);
        } else if (interaction.type == InteractionType.ApplicationCommand && isChatInputApplicationCommandInteraction(interaction)) {
            const command = this.commands.get(interaction.data.name);

            if (!command) {
                return createEphemeralResponse("could not find command: " + interaction.data.name);
            }

            return await command.execute(interaction);
        } else {
            return {
                type: InteractionResponseType.ChannelMessageWithSource,
                data: {
                    content: "Unknown command!",
                    flags: MessageFlags.Ephemeral
                }
            };
        }
    }


    public async registerCommands(guildId: string): Promise<void> {
        this.registerCommand(new StartQuizCommand(this.botService));
        this.registerCommand(new StopQuizCommand(this.botService));
        this.registerCommand(new NextQuestionCommand(this.botService));
        this.registerCommand(new AddQuestionToBankCommand());
        this.registerCommand(new DeleteQuestionFromBankCommand());
        this.registerCommand(new DeleteQuestionBankCommand());

        const commandData = Object.values(this.commands).map(command => command.data().toJSON());
        try {
            console.log('Started refreshing application (/) commands.');
            await this.rest.put(
                Routes.applicationGuildCommands(this.clientId, guildId), {body: commandData});
            console.log('Successfully reloaded application (/) commands.');
        } catch (error) {
            console.error(error);
        }
    }

    private registerCommand(command: IDiscordCommand) {
        this.commands.set(command.name, command);
    }
}
import {IDiscordCommand} from "./discordCommand";
import {SlashCommandBuilder, SlashCommandOptionsOnlyBuilder} from "@discordjs/builders";
import {
    APIChatInputApplicationCommandInteraction,
    APIInteractionResponse,
} from "discord-api-types/v10";
import {deleteQuestionBank} from "../../util/questionStorage";
import {createEphemeralResponse, generateErrorResponse, generateOptionMissingErrorResponse} from "../../util/interactionHelpers";

export class DeleteQuestionBankCommand implements IDiscordCommand {
    public data(): SlashCommandOptionsOnlyBuilder {
        return new SlashCommandBuilder()
            .setName(this.name)
            .setDescription('Delete a question bank')
            .addStringOption(option =>
                option.setName('questionbankname')
                    .setDescription('The name of the question bank')
                    .setRequired(true)
            );
    }

    public name  = 'deleteQuestionBank';

    public async execute(interaction: APIChatInputApplicationCommandInteraction): Promise<APIInteractionResponse> {
        try {

            const bankName = interaction.data.options?.getStringOption('questionbankname');

            if (!bankName) {
                return generateOptionMissingErrorResponse('name of the question bank');
            }

            await deleteQuestionBank(bankName);

            return createEphemeralResponse(`Deleted question bank: ${bankName}`);
        }
        catch (error) {
            return generateErrorResponse(error as Error);
        }
    }
}

import {IDiscordCommand} from "./discordCommand";
import {SlashCommandBuilder, SlashCommandOptionsOnlyBuilder} from "@discordjs/builders";
import {
    APIChatInputApplicationCommandInteraction,
    APIInteractionResponse
} from "discord-api-types/v10";
import {deleteQuestion} from "../../util/questionStorage";
import {createEphemeralResponse, generateErrorResponse, generateOptionMissingErrorResponse} from "../../util/interactionHelpers";

export class DeleteQuestionFromBankCommand implements IDiscordCommand {
    data(): SlashCommandOptionsOnlyBuilder {
        return new SlashCommandBuilder()
            .setName(this.name)
            .setDescription('Delete a question from a question bank')
            .addStringOption(option =>
                option.setName('questionbankname')
                    .setDescription('The name of the question bank')
                    .setRequired(true)
            )
            .addStringOption(option =>
                option.setName('questionid')
                    .setDescription('The ID of the question')
                    .setRequired(true)
            );
    }

    name  = 'deleteQuestionFromBank';

    async execute(interaction: APIChatInputApplicationCommandInteraction): Promise<APIInteractionResponse> {
        try {
            const bankName = interaction.data.options?.getStringOption('questionbankname');
            const questionId = interaction.data.options?.getStringOption('questionid');

            // ... inside your execute method ...
            if (!bankName) {
                return generateOptionMissingErrorResponse('name of the question bank');
            }

            if (!questionId) {
                return generateOptionMissingErrorResponse('name of the question id');
            }

            await deleteQuestion(bankName, questionId);

            return createEphemeralResponse(`Deleted question: ${questionId} from ${bankName}`);
        }
        catch (error) {
            return generateErrorResponse(error as Error);
        }
    }
}
import { APIChatInputApplicationCommandInteraction, APIInteractionResponse, APIModalSubmitInteraction } from "discord-api-types/v10";
import {SlashCommandOptionsOnlyBuilder} from "@discordjs/builders";

export interface IDiscordCommand {
    data(): SlashCommandOptionsOnlyBuilder;

    execute(interaction: APIChatInputApplicationCommandInteraction): Promise<APIInteractionResponse>;

    name: string; // Symbol property (optional)
}

export interface IModalHandlerCommand extends IDiscordCommand {
    handleModalSubmit(interaction: APIModalSubmitInteraction): Promise<APIInteractionResponse>; // Handles modal submission
}
import {IDiscordCommand} from "./discordCommand";
import {DiscordBotService} from "../discordBotService";
import {SlashCommandBuilder, SlashCommandOptionsOnlyBuilder} from "@discordjs/builders";
import {APIChatInputApplicationCommandInteraction, APIInteractionResponse} from "discord-api-types/v10";
import {createEphemeralResponse, generateErrorResponse, generateOptionMissingErrorResponse} from "../../util/interactionHelpers";

export class NextQuestionCommand implements IDiscordCommand {
    constructor(private discordBotService: DiscordBotService) {
    }

    data(): SlashCommandOptionsOnlyBuilder {
        return new SlashCommandBuilder()
            .setName(this.name)
            .setDescription('Show the next quiz question');
    }

    name = "nextQuestion";

    async execute(interaction: APIChatInputApplicationCommandInteraction): Promise<APIInteractionResponse> {
        try {
            const guildId = interaction.guild_id;

            if (!guildId)
            {
                return generateOptionMissingErrorResponse('guild id');
            }

            const quizManager = await this.discordBotService.getQuizManager(guildId);

            if (!quizManager)
            {
                return generateOptionMissingErrorResponse('invalid quiz manager');
            }

            await quizManager.sendQuizQuestion(interaction.channel.id);

            return createEphemeralResponse('Showing next question.');
        } catch (error) {
            return generateErrorResponse(error as Error);
        }
    }
}
import {IDiscordCommand} from "./discordCommand";
import {DiscordBotService} from "../discordBotService";
import {APIChatInputApplicationCommandInteraction, APIInteractionResponse} from "discord-api-types/v10";
import {createEphemeralResponse, generateErrorResponse, generateOptionMissingErrorResponse} from "../../util/interactionHelpers";
import {SlashCommandBuilder, SlashCommandOptionsOnlyBuilder} from "@discordjs/builders";

export class StartQuizCommand implements IDiscordCommand {
    constructor(private discordBotService: DiscordBotService) {
    }

    public data(): SlashCommandOptionsOnlyBuilder {
        return new SlashCommandBuilder()
            .setName(this.name)
            .setDescription('Start a quiz')
            .addStringOption(option =>
                option.setName('bankname')
                    .setDescription('The name of the question bank')
                    .setRequired(true)
            );
    }

    public name = 'startquiz';

    public async execute(interaction: APIChatInputApplicationCommandInteraction): Promise<APIInteractionResponse> {
        try {
            const guildId = interaction.guild_id;

            if (!guildId) {
                return generateOptionMissingErrorResponse('guild id');
            }

            const bankName = interaction.data.options?.getStringOption('bankname');

            if (!bankName) {
                return generateOptionMissingErrorResponse('name of the question bank');
            }

            const quizManager = await this.discordBotService.getQuizManager(guildId);
            await quizManager.startQuiz(interaction.channel.id, bankName);
            return createEphemeralResponse(`Started quiz with question bank: ${bankName}`);
        } catch (error) {
            return generateErrorResponse(error as Error);
        }
    }
}
import {IDiscordCommand} from "./discordCommand";
import {DiscordBotService} from "../discordBotService";
import {SlashCommandBuilder, SlashCommandOptionsOnlyBuilder} from "@discordjs/builders";
import {APIChatInputApplicationCommandInteraction, APIInteractionResponse} from "discord-api-types/v10";
import {createEphemeralResponse, generateErrorResponse, generateOptionMissingErrorResponse} from "../../util/interactionHelpers";

export class StopQuizCommand implements IDiscordCommand {
    constructor(private discordBotService: DiscordBotService) {
    }

    data(): SlashCommandOptionsOnlyBuilder {
        return new SlashCommandBuilder()
            .setName(this.name)
            .setDescription('Stop the current quiz');
    }

    name = 'stopquiz';

    async execute(interaction: APIChatInputApplicationCommandInteraction): Promise<APIInteractionResponse> {
        try {
            const guildId = interaction.guild_id;

            if (!guildId) {
                return generateOptionMissingErrorResponse('guild id');
            }


            const quizManager = await this.discordBotService.getQuizManager(guildId);

            await quizManager.stopQuiz(interaction.channel.id);

            return createEphemeralResponse(`Stopped quiz`);
        }
        catch (error)
        {
            return generateErrorResponse(error as Error);
        }
    }
}
import {QuizManager} from "./quizManager";
import {CommandManager} from "./actions/commandManager";
import {REST} from "@discordjs/rest";
import {APIInteraction, InteractionResponseType} from "discord-api-types/v10";

export class DiscordBotService {
    private readonly rest: REST;
    private quizManagers: Map<string, Promise<QuizManager>>;
    private commandManager : CommandManager;

    constructor(private readonly token: string, private readonly clientId: string) {
        this.rest = new REST({ version: '10' }).setToken(this.token);
        this.quizManagers = new Map();
        this.commandManager = new CommandManager(this, this.clientId, this.rest);
    }

    public async start(guildId : string) {
        await this.commandManager.registerCommands(guildId);
    }

    public async getQuizManager(guildId: string) : Promise<QuizManager> {
        const manager = await this.quizManagers.getOrAdd(
            guildId,
            async () =>
            {
                const quizManager = new QuizManager(this.rest);
                return quizManager;
            });

        if (!manager) throw new Error();
        return manager;
    }

    public async handleInteraction(interaction: APIInteraction) {
        // Delegate interaction handling to the CommandManager
        const response = await this.commandManager.handleInteraction(interaction);

        if (!response) {
            // Handle cases where the CommandManager doesn't provide a response (e.g., unknown interaction type)
            console.warn("Unknown interaction type or no response from CommandManager.");
            return { type: InteractionResponseType.Pong }; // Or provide a more appropriate default response
        }

        return response;
    }
}
import { QuizState } from "./quizState";
import { getQuestions } from "../util/questionStorage";
import SetIntervalAsync from "set-interval-async";
import {
    APIInteraction, APIInteractionResponse,
    ButtonStyle,
    InteractionResponseType, InteractionType, MessageFlags,
    Routes
} from "discord-api-types/v10";
import { REST } from "@discordjs/rest";
import { ActionRowBuilder, ButtonBuilder, EmbedBuilder } from "@discordjs/builders";
import { createEphemeralResponse } from "../util/interactionHelpers";
import { Question } from "../question";
import { firstValueFrom, timer } from "rxjs";

const sleep = (ms: number) => firstValueFrom(timer(ms));

export class QuizManager {
    private quizzes: Map<string, QuizState>;

    private static readonly QUESTION_DURATION_MS = 20000; // 20 seconds to answer
    private static readonly SUMMARY_DURATION_MS = 5000; // 5 seconds to show summary

    constructor(private readonly rest: REST) {
        this.quizzes = new Map();
    }

    public async startQuiz(channelId: string, questionBankName: string): Promise<void> {
        const questions = await getQuestions(questionBankName);

        const quiz: QuizState = {
            currentQuestionIndex: 0,
            questionBank: questions,
            activeUsers: new Map(),
            quizInterval: null,
            correctUsers: new Set<string>(),
        };

        this.quizzes.set(channelId, quiz);

        await this.sendQuizQuestion(channelId);
    }

    public async stopQuiz(channelId: string) {
        const quiz = this.quizzes.get(channelId);
        if (quiz && quiz.quizInterval) {
            await SetIntervalAsync.clearIntervalAsync(quiz.quizInterval);
        }
        this.quizzes.delete(channelId);
    }

    private async sendQuizQuestion(channelId: string) {
        const quiz = this.quizzes.get(channelId);
        if (!quiz) return;

        if (quiz.currentQuestionIndex >= quiz.questionBank.length) {
            await this.showScores(channelId);
            return;
        }

        const question = quiz.questionBank[quiz.currentQuestionIndex];
        quiz.correctUsers.clear();

        if (!question) return;

        quiz.currentQuestionIndex++;

        const embed = new EmbedBuilder()
            .setTitle('Quiz Question')
            .setDescription(`**Question**: ${question.question}\n` +
                question.answers.map((answer, index) => `${String.fromCharCode(65 + index)}: ${answer.answer}`).join('\n'))
            .setFooter({ text: 'Select the correct answer by clicking the buttons below.' });

        if (question.imageUrl) {
            embed.setImage(question.imageUrl);
        }

        const buttons = new ActionRowBuilder<ButtonBuilder>().addComponents(
            question.answers.map((answer, index) =>
                new ButtonBuilder()
                    .setCustomId(`answer_${answer.answerId}`)
                    .setLabel(String.fromCharCode(65 + index))
                    .setStyle(ButtonStyle.Primary)
            )
        );

        await this.rest.post(Routes.channelMessages(channelId), {
            body: {
                embeds: [embed.toJSON()],
                components: [buttons.toJSON()],
            },
        });

        quiz.quizInterval = SetIntervalAsync.setIntervalAsync(async () => {
            await this.sendQuestionSummary(channelId, question);
            await sleep(QuizManager.SUMMARY_DURATION_MS);
            await this.sendQuizQuestion(channelId);
        }, QuizManager.QUESTION_DURATION_MS);
    }

    private async sendQuestionSummary(channelId: string, question: Question): Promise<void> {
        const quiz = this.quizzes.get(channelId);
        if (!quiz) return;

        const correctAnswerText = question.answers[question.correctAnswerIndex]?.answer;
        const correctCount = quiz.correctUsers.size;

        const summaryEmbed = new EmbedBuilder()
            .setTitle(`Summary for Question ${quiz.currentQuestionIndex}`)
            .setDescription(`${correctCount} user(s) answered correctly!\n` +
                `The correct answer was: ${correctAnswerText}\n` +
                (question.explanation ? `Explanation: ${question.explanation}` : ''));

        if (question.explanationImageUrl) {
            summaryEmbed.setImage(question.explanationImageUrl);
        }

        await this.rest.post(Routes.channelMessages(channelId), {
            body: {
                embeds: [summaryEmbed.toJSON()],
            },
        });
    }

    public async handleAnswer(interaction: APIInteraction): Promise<APIInteractionResponse> {
        if (interaction.type !== InteractionType.MessageComponent) {
            return createEphemeralResponse('Invalid interaction type.');
        }

        const quiz = this.quizzes.get(interaction.channel.id);
        if (!quiz) {
            return createEphemeralResponse('No quiz found for this channel.');
        }

        const question = quiz.questionBank[quiz.currentQuestionIndex - 1];
        if (!question) {
            return createEphemeralResponse('No quiz question found for this channel.');
        }

        const userId = interaction.user?.id;
        const selectedAnswerId = interaction.data.custom_id.split('_')[1];

        if (!userId) {
            return createEphemeralResponse('Invalid user id');
        }

        const selectedAnswerIndex = question.answers.findIndex(answer => answer.answerId === selectedAnswerId);

        if (selectedAnswerIndex === question.correctAnswerIndex) {
            quiz.activeUsers.set(userId, (quiz.activeUsers.get(userId) || 0) + 1);
            quiz.correctUsers.add(userId);
            return {
                type: InteractionResponseType.ChannelMessageWithSource,
                data: {
                    content: 'Correct!',
                    flags: MessageFlags.Ephemeral
                }
            };
        } else {
            return {
                type: InteractionResponseType.ChannelMessageWithSource,
                data: {
                    content: 'Incorrect!',
                    flags: MessageFlags.Ephemeral
                }
            };
        }
    }

    public async showScores(channelId: string) {
        const quiz = this.quizzes.get(channelId);
        if (!quiz) return;

        const scoreEntries = Array.from(quiz.activeUsers.entries());
        scoreEntries.sort(([, scoreA], [, scoreB]) => scoreB - scoreA); // Higher scores first

        let scoreMessage = '**Quiz Scores**\n';
        for (const [userId, score] of scoreEntries) {
            scoreMessage += `<@${userId}>: ${score} points\n`;
        }

        await this.rest.post(Routes.channelMessages(channelId), {
            body: {
                content: scoreMessage,
            },
        });

        quiz.activeUsers.clear();
    }
}
import {Question} from "../question";
import {SetIntervalAsyncTimer} from "set-interval-async";

export interface QuizState {
    currentQuestionIndex: number;
    questionBank: Question[];
    activeUsers: Map<string, number>;
    correctUsers: Set<string>;
    quizInterval: SetIntervalAsyncTimer<[]> | null;
}
export function throwError(message: string): never {
    throw new Error(message);
}
import {
    APIApplicationCommandInteractionDataOption, APIInteractionResponse,
    ApplicationCommandOptionType, InteractionResponseType, MessageFlags,
} from "discord-api-types/v10";

declare global {
    interface Array<T> {
        getStringOption(this: T[], optionName: string): string | null;
    }
}

export function generateErrorResponse(error: Error): APIInteractionResponse {
    return {
        type: InteractionResponseType.ChannelMessageWithSource,
        data: {
            content: error.message,
            flags: MessageFlags.Ephemeral
        }
    };
}

export function generateOptionMissingErrorResponse(optionName: string): APIInteractionResponse {
    return {
        type: InteractionResponseType.ChannelMessageWithSource,
        data: {
            content: `The ${optionName} was not specified!`,
            flags: MessageFlags.Ephemeral
        }
    };
}

export function createEphemeralResponse(content: string): APIInteractionResponse {
    return {
        type: InteractionResponseType.ChannelMessageWithSource,
        data: {
            content,
            flags: MessageFlags.Ephemeral
        }
    };
}

Array.prototype.getStringOption = function (optionName: string) {
    const option = this.find(opt => opt.name === optionName);

    if (!option) {
        throw new Error(`The ${optionName} was not specified!`);
    }

    if (option.type !== ApplicationCommandOptionType.String) {
        throw new Error(`The ${optionName} was not specified correctly as a string!`);
    }

    return option.value as string;
};

export function getStringOption(options: APIApplicationCommandInteractionDataOption[] | undefined, optionName: string): string | null {
    const option = options?.find(opt => opt.name === optionName);

    if (!option) {
        throw new Error(`The ${optionName} was not specified!`);
    }

    if (option.type !== ApplicationCommandOptionType.String) {
        throw new Error(`The ${optionName} was not specified correctly as a string!`);
    }

    return option.value as string;
}
interface Map<K, V> {
    getOrAdd(key: K, defaultValue: () => V): V | undefined;
}

Map.prototype.getOrAdd = function<K, V> (this: Map<K, V>, key: K, defaultValue: () => V): V | undefined {
    if (this.has(key)) {
        return this.get(key); // Safe non-null assertion, since we checked with 'has'
    } else {
        const value = defaultValue();
        this.set(key, value);
        return value;
    }
};
import {TableClient, TableEntity, odata, TableDeleteEntityHeaders} from "@azure/data-tables";
import { Question } from "../question";
import { v4 as uuidv4 } from 'uuid';
import {throwError} from "./errorHelpers";

const client = TableClient.fromConnectionString(process.env.AZURE_STORAGE_CONNECTION_STRING ?? throwError('invalid azure connection string'), 'QuizQuestions');

export async function getQuestions(bankName: string): Promise<Question[]> {
    const entitiesIter = client.listEntities<TableEntity<Question>>({
        queryOptions: {
            filter: odata`PartitionKey eq ${bankName}`
        }
    });

    if (!entitiesIter) {
        return [];
    }

    const entities: Question[] = [];
    for await (const entity of entitiesIter) {
        entities.push(fromTableEntity(entity));
    }

    return entities;
}

export async function addQuestion(question: Question): Promise<void> {
    const entity = toTableEntity(question);
    await client.createEntity(entity);
}

export async function addQuestions(questions: Question[]): Promise<void> {
    const addPromises = questions.map(question => {
        const entity = toTableEntity(question);
        return client.createEntity(entity);
    });
    await Promise.all(addPromises);
}

export async function deleteQuestionBank(bankName: string): Promise<void> {
    const entitiesToDelete = client.listEntities<TableEntity<Question>>({
        queryOptions: {
            filter: odata`PartitionKey eq ${bankName}`
        }
    });

    const deletePromises: Promise<TableDeleteEntityHeaders>[] = [];
    for await (const entity of entitiesToDelete) {
        deletePromises.push(client.deleteEntity(entity.partitionKey, entity.rowKey));
    }
    await Promise.all(deletePromises);
}

export async function deleteQuestion(bankName: string, questionId: string): Promise<void> {
    await client.deleteEntity(bankName, questionId);
}

function toTableEntity(question: Question): TableEntity<Question> {
    const rowKey = question.questionId || uuidv4();
    return {
        partitionKey: question.bankName,
        rowKey: rowKey,  // Generate RowKey if not provided
        question: question.question,
        questionId: rowKey,
        bankName: question.bankName,
        answers: question.answers,
        correctAnswerIndex: question.correctAnswerIndex,
        imageUrl: question.imageUrl
    };
}

function fromTableEntity(entity: TableEntity<Question>): Question {
    return {
        bankName: entity.partitionKey,
        questionId: entity.rowKey,
        question: entity.question,
        answers: entity.answers,
        correctAnswerIndex: entity.correctAnswerIndex,
        imageUrl: entity.imageUrl
    };
}
export interface Answer {
    answerId: string;
    answer: string;
}
import { Answer } from "./answer";

export interface Question {
    bankName: string;
    questionId: string;
    question: string;
    answers: Answer[];
    correctAnswerIndex: number;
    imageUrl?: string; // Optional property for the image URL
    explanation?: string;
    explanationImageUrl?: string;
}
